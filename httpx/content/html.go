//spellchecker:words content
package content

//spellchecker:words html template http github pkglib httpx minify recovery
import (
	"html/template"
	"net/http"

	"github.com/tkw1536/pkglib/httpx"
	"github.com/tkw1536/pkglib/minify"
	"github.com/tkw1536/pkglib/recovery"
)

//spellchecker:words HTMLI websockets minifier

// WriteHTML writes an html response to r into w.
//
// The response to be written is generated by rendering the template with the given context.
// The response is automatically minified.
//
// If err is not nil, an error response is rendered instead, see [httpx.HTMLInterceptor].
func WriteHTML[C any](context C, e error, template *template.Template, w http.ResponseWriter, r *http.Request) error {
	return WriteHTMLI(context, e, template, httpx.HTMLInterceptor, w, r)
}

// WriteHTMLI is like [WriteHTML], but uses a custom error interceptor.
func WriteHTMLI[C any](context C, e error, template *template.Template, interceptor httpx.ErrInterceptor, w http.ResponseWriter, r *http.Request) (err error) {
	// intercept any errors
	if interceptor.Intercept(w, r, e) {
		return nil
	}

	// write out the response as html
	w.Header().Set("Content-Type", httpx.ContentTypeHTML)

	// minify html!
	minifier := minify.Minify(httpx.ContentTypeHTML, w)
	defer func() {
		errClose := minifier.Close()
		if err == nil {
			err = errClose
		}
	}()

	// return it to the client
	// and if there is an error, write it to the client
	{
		err := template.Execute(minifier, context)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
		}
		return err
	}
}

// HTMLHandler is a [http.Handler] that responds to requests with html.
//
// C is the type of the context to be passed to the Template
type HTMLHandler[C any] struct {
	Handler func(r *http.Request) (C, error)

	Template *template.Template // Template is the template to be rendered into responses

	Interceptor             httpx.ErrInterceptor
	LogTemplateExecuteError httpx.ErrorLogger
}

// ServeHTTP calls the handler, and then passes it and the template to WriteHTML.
func (h HTMLHandler[T]) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// call the function
	result, err := recovery.Safe(func() (T, error) { return h.Handler(r) })
	{
		err := WriteHTMLI(result, err, h.Template, h.Interceptor, w, r)
		if err != nil && h.LogTemplateExecuteError != nil {
			h.LogTemplateExecuteError(r, err)
		}
	}
}

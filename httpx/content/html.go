package content

import (
	"html/template"
	"net/http"

	"github.com/tkw1536/pkglib/httpx"
	"github.com/tkw1536/pkglib/minify"
	"github.com/tkw1536/pkglib/recovery"
)

// spellchecker:words HTMLI httpx websockets

// WriteHTML writes an html response to r into w.
//
// The response to be written is generated by rendering the template with the given context.
// The response is automatically minified.
//
// If err is not nil, an error response is rendered instead, see [httpx.HTMLInterceptor].
func WriteHTML[C any](context C, err error, template *template.Template, w http.ResponseWriter, r *http.Request) error {
	return WriteHTMLI(context, err, template, httpx.HTMLInterceptor, w, r)
}

// WriteHTMLI is like [WriteHTML], but uses a custom error interceptor.
func WriteHTMLI[C any](context C, err error, template *template.Template, interceptor httpx.ErrInterceptor, w http.ResponseWriter, r *http.Request) error {
	// intercept any errors
	if interceptor.Intercept(w, r, err) {
		return nil
	}

	// write out the response as html
	w.Header().Set("Content-Type", httpx.ContentTypeHTML)
	w.WriteHeader(http.StatusOK)

	// minify html!
	minifier := minify.Minify(httpx.ContentTypeHTML, w)
	defer minifier.Close()

	// and return the template
	return template.Execute(minifier, context)
}

// HTMLHandler is a [http.Handler] that responds to requests with html.
//
// C is the type of the context to be passed to the Template
type HTMLHandler[C any] struct {
	Handler func(r *http.Request) (C, error)

	// Template is the template to be rendered into responses
	Template *template.Template

	Interceptor httpx.ErrInterceptor
}

// ServeHTTP calls the handler, and then passes it and the template to WriteHTML.
func (h HTMLHandler[T]) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// call the function
	result, err := recovery.Safe(func() (T, error) { return h.Handler(r) })
	WriteHTMLI(result, err, h.Template, h.Interceptor, w, r)
}
